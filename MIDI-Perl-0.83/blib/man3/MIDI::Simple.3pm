.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MIDI::Simple 3pm"
.TH MIDI::Simple 3pm "2010-12-23" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIDI::Simple \- procedural/OOP interface for MIDI composition
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use MIDI::Simple;
\& new_score;
\& text_event \*(Aqhttp://www.ely.anglican.org/parishes/camgsm/bells/chimes.html\*(Aq;
\& text_event \*(AqLord through this hour/ be Thou our guide\*(Aq;
\& text_event \*(Aqso, by Thy power/ no foot shall slide\*(Aq;
\& set_tempo 500000;  # 1 qn => .5 seconds (500,000 microseconds)
\& patch_change 1, 8;  # Patch 8 = Celesta
\&
\& noop c1, f, o5;  # Setup
\& # Now play
\& n qn, Cs;    n F;   n Ds;  n hn, Gs_d1;
\& n qn, Cs;    n Ds;  n F;   n hn, Cs;
\& n qn, F;     n Cs;  n Ds;  n hn, Gs_d1;
\& n qn, Gs_d1; n Ds;  n F;   n hn, Cs;
\&
\& write_score \*(Aqwestmister_chimes.mid\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module sits on top of all the \s-1MIDI\s0 modules \*(-- notably MIDI::Score
(so you should skim MIDI::Score) \*(-- and is meant to serve as a
basic interface to them, for composition.  By composition, I mean
composing anew; you can use this module to add to or modify existing
\&\s-1MIDI\s0 files, but that functionality is to be considered a bit experimental.
.PP
This module provides two related but distinct bits of functionality:
1) a mini-language (implemented as procedures that can double as
methods) for composing by adding notes to a score structure; and 2)
simple functions for reading and writing scores, specifically the
scores you make with the composition language.
.PP
The fact that this module's interface is both procedural and
object-oriented makes it a definite two-headed beast.  The parts of
the guts of the source code are not for the faint of heart.
.SH "NOTE ON VERSION CHANGES"
.IX Header "NOTE ON VERSION CHANGES"
This module is somewhat incompatible with the MIDI::Simple versions
before .700 (but that was a \fIlooong\fR time ago).
.SS "\s-1OBJECT STRUCTURE\s0"
.IX Subsection "OBJECT STRUCTURE"
A MIDI::Simple object is a data structure with the following
attributes:
.IP "Score" 4
.IX Item "Score"
This is a list of all the notes (each a listref) that constitute this
one-track musical piece.  Scores are explained in MIDI::Score.
You probably don't need to access the Score attribute directly, but be
aware that this is where all the notes you make with \f(CW\*(C`n\*(C'\fR events go.
.IP "Time" 4
.IX Item "Time"
This is a non-negative integer expressing the start-time, in ticks
from the start-time of the \s-1MIDI\s0 piece, that the next note pushed to
the Score will have.
.IP "Channel" 4
.IX Item "Channel"
This is a number in the range [0\-15] that specifies the current default
channel for note events.
.IP "Duration" 4
.IX Item "Duration"
This is a non-negative (presumably nonzero) number expressing, in
ticks, the current default length of note events, or rests.
.IP "Octave" 4
.IX Item "Octave"
This is a number in the range [0\-10], expressing what the current
default octave number is.  This is used for figuring out exactly
what note-pitch is meant by a relative note-pitch specification
like \*(L"A\*(R".
.IP "Notes" 4
.IX Item "Notes"
This is a list (presumably non-empty) of note-pitch specifications,
\&\fIas note numbers\fR in the range [0\-127].
.IP "Volume" 4
.IX Item "Volume"
This is an integer in the range [0\-127] expressing the current default
volume for note events.
.IP "Tempo" 4
.IX Item "Tempo"
This is an integer expressing the number of ticks a quarter note
occupies.  It's currently 96, and you shouldn't alter it unless you
\&\fIreally\fR know what you're doing.  If you want to control the tempo of
a piece, use the \f(CW\*(C`set_tempo\*(C'\fR routine, instead.
.IP "Cookies" 4
.IX Item "Cookies"
This is a hash that can be used by user-defined object-methods for
storing whatever they want.
.PP
Each package that you call the procedure \f(CW\*(C`new_score\*(C'\fR from, has a
default MIDI::Simple object associated with it, and all the above
attributes are accessible as:
.PP
.Vb 2
\&  @Score $Time $Channel $Duration $Octave
\&  @Notes $Volume $Tempo %Cookies
.Ve
.PP
(Although I doubt you'll use these from any package other than
\&\*(L"main\*(R".)  If you don't know what a package is, don't worry about it.
Just consider these attributes synonymous with the above-listed
variables.  Just start your programs with
.PP
.Vb 2
\&  use MIDI::Simple;
\&  new_score;
.Ve
.PP
and you'll be fine.
.SS "Routine/Method/Procedure"
.IX Subsection "Routine/Method/Procedure"
MIDI::Simple provides some pure functions (i.e., things that take
input, and give a return value, and that's all they do), but what
you're mostly interested in its routines.  By \*(L"routine\*(R" I mean a
subroutine that you call, whether as a procedure or as a method, and
that affects data structures other than the return value.
.PP
Here I'm using \*(L"procedure\*(R" to mean a routine you call like this:
.PP
.Vb 3
\&  name(parameters...);
\&  # or, just maybe:
\&  name;
.Ve
.PP
(In technical terms, I mean a non-method subroutine that can have side
effects, and which may not even provide a useful return value.)  And
I'm using \*(L"method\*(R" to mean a routine you call like this:
.PP
.Vb 1
\&  $object\->name(parameters);
.Ve
.PP
So bear these terms in mind when you see routines below that act
like one, or the other, or both.
.SS "\s-1MAIN ROUTINES\s0"
.IX Subsection "MAIN ROUTINES"
These are the most important routines:
.ie n .IP "\fBnew_score()\fR  or  $obj = MIDI::Simple\->\fBnew_score()\fR" 4
.el .IP "\fBnew_score()\fR  or  \f(CW$obj\fR = MIDI::Simple\->\fBnew_score()\fR" 4
.IX Item "new_score() or $obj = MIDI::Simple->new_score()"
As a procedure, this initializes the package's default object (Score,
etc.).  As a method, this is a constructor, returning a new
MIDI::Simple object.  Neither form takes any parameters.
.ie n .IP "n(...parameters...)  or  $obj\->n(...parameters...)" 4
.el .IP "n(...parameters...)  or  \f(CW$obj\fR\->n(...parameters...)" 4
.IX Item "n(...parameters...) or $obj->n(...parameters...)"
This uses the parameters given (and/or the state variables like
Volume, Channel, Notes, etc) to add a new note to the Score \*(-- or
several notes to the Score, if Notes has more than one element in it
\&\*(-- or no notes at all, if Notes is empty list.
.Sp
Then it moves Time ahead as appropriate.  See the section \*(L"Parameters
For n/r/noop\*(R", below.
.ie n .IP "r(...parameters...)  or  $obj\->r(...parameters...)" 4
.el .IP "r(...parameters...)  or  \f(CW$obj\fR\->r(...parameters...)" 4
.IX Item "r(...parameters...) or $obj->r(...parameters...)"
This is exactly like \f(CW\*(C`n\*(C'\fR, except it never pushes anything to Score,
but moves ahead Time.  (In other words, there is no such thing as a
rest-event; it's just a item during which there are no note-events
playing.)
.ie n .IP "noop(...parameters...)  or  $obj\->noop(...parameters...)" 4
.el .IP "noop(...parameters...)  or  \f(CW$obj\fR\->noop(...parameters...)" 4
.IX Item "noop(...parameters...) or $obj->noop(...parameters...)"
This is exactly like \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`r\*(C'\fR, except it never alters Score,
\&\fIand\fR never changes Time.  It is meant to be used for setting the
other state variables, i.e.: Channel, Duration, Octave, Volume, Notes.
.SS "Parameters for n/r/noop"
.IX Subsection "Parameters for n/r/noop"
A parameter in an \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`r\*(C'\fR, or \f(CW\*(C`noop\*(C'\fR call is meant to change an
attribute (\s-1AKA\s0 state variable), namely Channel, Duration, Octave,
Volume, or Notes.
.PP
Here are the kinds of parameters you can use in calls to n/r/noop:
.PP
* A numeric \fBvolume\fR parameter.  This has the form \*(L"V\*(R" followed by a
positive integer in the range 0 (completely inaudible?) to 127 (\s-1AS
LOUD AS POSSIBLE\s0).  Example: \*(L"V90\*(R" sets Volume to 90.
.PP
* An alphanumeric \fBvolume\fR parameter.  This is a key from the hash
\&\f(CW%MIDI::Simple::Volume\fR.  Current legal values are \*(L"ppp\*(R", \*(L"pp\*(R", \*(L"p\*(R",
\&\*(L"mp\*(R", \*(L"mezzo\*(R" (or \*(L"m\*(R"), \*(L"mf\*(R", \*(L"f\*(R", \*(L"ff\*(R", and \*(L"fff\*(R".  Example: \*(L"ff\*(R"
sets Volume to 112.  (Note that \*(L"m\*(R" isn't a good bareword, so use
\&\*(L"mezzo\*(R" instead, or just always remember to use quotes around \*(L"m\*(R".)
.PP
* A numeric \fBchannel\fR parameter.  This has the form \*(L"c\*(R" followed by a
positive integer 0 to 15.  Example: \*(L"c2\*(R", to set Channel to 2.
.PP
* A numeric \fBduration\fR parameter.  This has the form \*(L"d\*(R" followed by
a positive (presumably nonzero) integer.  Example: \*(L"d48\*(R", to set
Duration to 48.
.PP
* An alphabetic (or in theory, possibly alphanumeric) \fBduration\fR
parameter.  This is a key from the hash \f(CW%MIDI::Simple::Length\fR.
Current legal values start with \*(L"wn\*(R", \*(L"hn\*(R", \*(L"qn\*(R", \*(L"en\*(R", \*(L"sn\*(R" for
whole, half, quarter, eighth, or sixteenth notes.  Add \*(L"d\*(R" to the
beginning of any of these to get \*(L"dotted...\*(R" (e.g., \*(L"dqn\*(R" for a dotted
quarter note).  Add \*(L"dd\*(R" to the beginning of any of that first list to
get \*(L"double-dotted...\*(R"  (e.g., \*(L"ddqn\*(R" for a double-dotted quarter
note).  Add \*(L"t\*(R" to the beginning of any of that first list to get
\&\*(L"triplet...\*(R"  (e.g., \*(L"tsn\*(R" for a triplet sixteenth note \*(-- i.e. a note
such that 3 of them add up to something as long as one eighth note).
You may add to the contents of \f(CW%MIDI::Simple::Length\fR to support
whatever abbreviations you want, as long as the parser can't mistake
them for any other kind of n/r/noop parameter.
.PP
* A numeric, absolute \fBoctave\fR specification.  This has the form: an
\&\*(L"o\*(R" (lowercase oh), and then an integer in the range 0 to 10,
representing an octave 0 to 10.  The Octave attribute is used only in
resolving relative note specifications, as explained further below in
this section.  (All absolute note specifications also set Octave to
whatever octave they occur in.)
.PP
* A numeric, relative \fBoctave\fR specification.  This has the form:
\&\*(L"o_d\*(R" (\*(L"d\*(R" for down) or \*(L"o_u\*(R" (\*(L"u\*(R" for down), and then an integer.
This increments, or decrements, Octave.  E.g., if Octave is 6, \*(L"o_d2\*(R"
will decrement Octave by 2, making it 4.  If this moves Octave below
0, it is forced to 0.  Or if it moves Octave above 10, it is forced to
10.  (For more information, see the section \*(L"Invalid or Out-of-Range
Parameters to n/r/noop\*(R", below.)
.PP
* A numeric, absolute \fBnote\fR specification.  This has the form: an
optional \*(L"n\*(R", and then an integer in the range 0 to 127, representing
a note ranging from C0 to G10.  The source to \s-1MIDI\s0 has a useful
reference table showing the meanings of given note numbers.  Examples:
\&\*(L"n60\*(R", or \*(L"60\*(R", which each add a 60 to the list Notes.
.PP
Since this is a kind of absolute note specification, it sets Octave to
whatever octave the given numeric note occurs in.  E.g., \*(L"n60\*(R" is
\&\*(L"C5\*(R", and therefore sets Octave to 5.
.PP
The setting of the Notes list is a bit special, compared to how
setting the other attributes works.  If there are any note
specifications in a given parameter list for n, r, or noop, then all
those specifications together are assigned to Notes.
.PP
If there are no note specifications in the parameter list for n, r, or
noop, then Notes isn't changed.  (But see the description of \*(L"rest\*(R",
at the end of this section.)
.PP
So this:
.PP
.Vb 1
\&  n mf, n40, n47, n50;
.Ve
.PP
sets Volume to 80, and Notes to (40, 47, 50).  And it sets Octave,
first to 3 (since n40 is in octave 3), then to 3 again (since n47 =
B3), and then finally to 4 (since n50 = D4).
.PP
Note that this is the same as:
.PP
.Vb 1
\&  n n40, n47, n50, mf;
.Ve
.PP
The relative orders of parameters is \fBusually\fR irrelevant; but see
the section \*(L"Order of Parameters in a Call to n/r/noop\*(R", below.
.PP
* An alphanumeric, absolute \fBnote\fR specification.
.PP
These have the form: a string denoting a note within the octave (as
determined by \f(CW%MIDI::Simple::Note\fR \*(-- see below, in the description of
alphanumeric, relative note specifications), and then a number
denoting the octave number (in the range 0\-10).  Examples: \*(L"C3\*(R",
\&\*(L"As4\*(R" or \*(L"Asharp4\*(R", \*(L"Bf9\*(R" or \*(L"Bflat9\*(R".
.PP
Since this is a kind of absolute note specification, it sets Octave to
whatever octave the given numeric note occurs in.  E.g., \*(L"C3\*(R" sets
Octave to 3, \*(L"As4\*(R" sets Octave to 4, and \*(L"Bflat9\*(R" sets Octave to 9.
.PP
This:
.PP
.Vb 1
\&  n E3, B3, D4, mf;
.Ve
.PP
does the same as this example of ours from before:
.PP
.Vb 1
\&  n n40, n47, n50, mf;
.Ve
.PP
* An alphanumeric, relative \fBnote\fR specification.
.PP
These have the form: a string denoting a note within the octave (as
determined by \f(CW%MIDI::Simple::Note\fR), and then an optional parameter
\&\*(L"_u[number]\*(R" meaning \*(L"so many octaves up from the current octave\*(R" or
\&\*(L"_d[parameter]\*(R" meaning \*(L"so many octaves down from the current
octave\*(R".
.PP
Examples: \*(L"C\*(R", \*(L"As\*(R" or \*(L"Asharp\*(R", \*(L"Bflat\*(R" or \*(L"Bf\*(R", \*(L"C_d3\*(R", \*(L"As_d1\*(R" or
\&\*(L"Asharp_d1\*(R", \*(L"Bflat_u3\*(R" or \*(L"Bf_u3\*(R".
.PP
In resolving what actual notes these kinds of specifications denote,
the current value of Octave is used.
.PP
What's a legal for the first bit (before any optional octave up/down
specification) comes from the keys to the hash \f(CW%MIDI::Simple::Note\fR.
The current acceptable values are:
.PP
.Vb 12
\& C                                 (maps to the value 0)
\& Cs or Df or Csharp or Dflat       (maps to the value 1)
\& D                                 (maps to the value 2)
\& Ds or Ef or Dsharp or Eflat       (maps to the value 3)
\& E                                 (maps to the value 4)
\& F                                 (maps to the value 5)
\& Fs or Gf or Fsharp or Gflat       (maps to the value 6)
\& G                                 (maps to the value 7)
\& Gs or Af or Gsharp or Aflat       (maps to the value 8)
\& A                                 (maps to the value 9)
\& As or Bf or Asharp or Bflat       (maps to the value 10)
\& B                                 (maps to the value 11)
.Ve
.PP
(Note that these are based on the English names for these notes.  If
you prefer to add values to accomodate other strings denoting notes in
the octave, you may do so by adding to the hash \f(CW%MIDI::Simple::Note\fR
like so:
.PP
.Vb 7
\&  use MIDI::Simple;
\&  %MIDI::Simple::Note =
\&    (%MIDI::Simple::Note,  # keep all the old values
\&     \*(AqH\*(Aq => 10,
\&     \*(AqDo\*(Aq => 0,
\&     # ...etc...
\&    );
.Ve
.PP
But the values you add must not contain any characters outside the
range [A\-Za\-z\ex80\-\exFF]; and your new values must not look like
anything that could be any other kind of specification.  E.g., don't
add \*(L"mf\*(R" or \*(L"o3\*(R" to \f(CW%MIDI::Simple::Note\fR.)
.PP
Consider that these bits of code all do the same thing:
.PP
.Vb 1
\&  n E3, B3, D4, mf;       # way 1
\&  
\&  n E3, B,  D_u1, mf;     # way 2
\&  
\&  n o3, E, B,  D_u1, mf;  # way 3
\&  
\&  noop o3, mf;            # way 4
\&  n     E, B,  D_u1;
.Ve
.PP
or even
.PP
.Vb 1
\&  n o3, E, B, o4, D, mf;       # way 5!
\&  
\&  n o6, E_d3, B_d3, D_d2, mf;  # way 6!
.Ve
.PP
If a \*(L"_d[number]\*(R" would refer to a note in an octave below 0, it is
forced into octave 0.  If a \*(L"_u[number]\*(R" would refer to a note in an
octave above 10, it is forced into octave 10.  E.g., if Octave is 8,
\&\*(L"G_u4\*(R" would resolve to the same as \*(L"G10\*(R" (not \*(L"G12\*(R" \*(-- as that's out
of range); if Octave is 2, \*(L"G_d4\*(R" would resolve to the same as \*(L"G0\*(R".
(For more information, see the section \*(L"Invalid or Out-of-Range
Parameters to n/r/noop\*(R", below.)
.PP
* The string "\f(CW\*(C`rest\*(C'\fR" acts as a sort of note specification \*(-- it sets
Notes to empty-list.  That way you can make a call to \f(CW\*(C`n\*(C'\fR actually
make a rest:
.PP
.Vb 7
\&  n qn, G;    # makes a G quarter\-note
\&  n hn, rest; # half\-rest \-\- alters Notes, making it ()
\&  n C,G;      # half\-note chord: simultaneous C and G
\&  r;          # half\-rest \-\- DOESN\*(AqT alter Notes.
\&  n qn;       # quarter\-note chord: simultaneous C and G
\&  n rest;     # quarter\-rest
\&  n;          # another quarter\-rest
.Ve
.PP
(If you can follow the above code, then you understand.)
.PP
A "\f(CW\*(C`rest\*(C'\fR\*(L" that occurs in a parameter list with other note specs
(e.g., \*(R"n qn, A, rest, G") has \fBno effect\fR, so don't do that.
.SS "Order of Parameters in a Call to n/r/noop"
.IX Subsection "Order of Parameters in a Call to n/r/noop"
The order of parameters in calls to n/r/noop is not important except
insofar as the parameters change the Octave parameter, which may change
how some relative note specifications are resolved.  For example:
.PP
.Vb 2
\&  noop o4, mf;
\&  n G, B, A3, C;
.Ve
.PP
is the same as \*(L"n mf, G4, B4, A3, C3\*(R".  But just move that \*(L"C\*(R" to the
start of the list:
.PP
.Vb 2
\&  noop o4, mf;
\&  n C, G, B, A3;
.Ve
.PP
and you something different, equivalent to \*(L"n mf, C4, G4, B4, A3\*(R".
.PP
But note that you can put the \*(L"mf\*(R" anywhere without changing anything.
.PP
But \fBstylistically\fR, I strongly advise putting note parameters at the
\&\fBend\fR of the parameter list:
.PP
.Vb 3
\&  n mf, c10, C, B;  # 1. good
\&  n C, B, mf, c10;  # 2. bad
\&  n C, mf, c10, B;  # 3. so bad!
.Ve
.PP
3 is particularly bad because an uninformed/inattentive reader may get
the impression that the C may be at a different volume and on a
different channel than the B.
.PP
(Incidentally, \*(L"n C5,G5\*(R" and \*(L"n G5,C5\*(R" are the same for most purposes,
since the C and the G are played at the same time, and with the same
parameters (channel and volume); but actually they differ in which
note gets put in the Score first, and therefore which gets encoded
first in the \s-1MIDI\s0 file \*(-- but this makes no difference at all, unless
you're manipulating the note-items in Score or the \s-1MIDI\s0 events in a
track.)
.SS "Invalid or Out-of-Range Parameters to n/r/noop"
.IX Subsection "Invalid or Out-of-Range Parameters to n/r/noop"
If a parameter in a call to n/r/noop is uninterpretable, Perl dies
with an error message to that effect.
.PP
If a parameter in a call to n/r/noop has an out-of-range value (like
\&\*(L"o12\*(R" or \*(L"c19\*(R"), Perl dies with an error message to that effect.
.PP
As somewhat of a merciful exception to this rule, if a parameter in a
call to n/r/noop is a relative specification (whether like \*(L"o_d3\*(R" or
\&\*(L"o_u3\*(R", or like \*(L"G_d3\*(R" or \*(L"G_u3\*(R") which happens to resolve to an
out-of-range value (like \*(L"G_d3\*(R" given an Octave value of 2), then Perl
will \fBnot\fR die, but instead will silently try to bring that note back
into range, by forcing it up to octave 0 (if it would have been
lower), or down into 9 or 10 (if it would have been an octave higher
than 10, or a note higher than G10), as appropriate.
.PP
(This becomes strange in that, given an Octave of 8, \*(L"G_u4\*(R" is forced
down to G10, but \*(L"A_u4\*(R" is forced down to an A9.  But that boundary
has to pop up someplace \*(-- it's just unfortunate that it's in the
middle of octave 10.)
.SS "\s-1ATTRIBUTE METHODS\s0"
.IX Subsection "ATTRIBUTE METHODS"
The object attributes discussed above are readable and writeable with
object methods.  For each attribute there is a read/write method, and a
read-only method that returns a reference to the attribute's value:
.PP
.Vb 11
\&  Attribute ||  R/W\-Method ||   RO\-R\-Method
\&  \-\-\-\-\-\-\-\-\-\-++\-\-\-\-\-\-\-\-\-\-\-\-\-++\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Score     ||  Score      ||   Score_r      (returns a listref)
\&  Notes     ||  Notes      ||   Notes_r      (returns a listref)
\&  Time      ||  Time       ||   Time_r       (returns a scalar ref)
\&  Duration  ||  Duration   ||   Duration_r   (returns a scalar ref)
\&  Channel   ||  Channel    ||   Channel_r    (returns a scalar ref)
\&  Octave    ||  Octave     ||   Octave_r     (returns a scalar ref)
\&  Volume    ||  Volume     ||   Volume_r     (returns a scalar ref)
\&  Tempo     ||  Tempo      ||   Tempo_r      (returns a scalar ref)
\&  Cookies   ||  Cookies    ||   Cookies_r    (returns a hashref)
.Ve
.PP
To read any of the above via a R/W\-method, call with no parameters,
e.g.:
.PP
.Vb 1
\&  $notes = $obj\->Notes;  # same as $obj\->Notes()
.Ve
.PP
The above is the read-attribute (\*(L"get\*(R") form.
.PP
To set the value, call with parameters:
.PP
.Vb 1
\&  $obj\->Notes(13,17,22);
.Ve
.PP
The above is the write-attribute (\*(L"put\*(R") form.  Incidentally, when
used in write-attribute form, the return value is the same as the
parameters, except for Score or Cookies.  (In those two cases, I've
suppressed it for efficiency's sake.)
.PP
Alternately (and much more efficiently), you can use the read-only
reference methods to read or alter the above values;
.PP
.Vb 5
\&  $notes_r = $obj\->Notes_r;
\&  # to read:
\&  @old_notes = @$notes_r;
\&  # to write:
\&  @$notes_r = (13,17,22);
.Ve
.PP
And this is the only way to set Cookies, Notes, or Score to a (),
like so:
.PP
.Vb 2
\&  $notes_r = $obj\->Notes_r;
\&  @$notes_r = ();
.Ve
.PP
Since this:
.PP
.Vb 1
\&  $obj\->Notes;
.Ve
.PP
is just the read-format call, remember?
.PP
Like all methods in this class, all the above-named attribute methods
double as procedures that act on the default object \*(-- in other words,
you can say:
.PP
.Vb 5
\&  Volume 10;              # same as:  $Volume = 10;
\&  @score_copy = Score;    # same as:  @score_copy = @Score
\&  Score @new_score;       # same as:  @Score = @new_score;
\&  $score_ref = Score_r;   # same as:  $score_ref = \e@Score
\&  Volume(Volume + 10)     # same as:  $Volume += 10
.Ve
.PP
But, stylistically, I suggest not using these procedures \*(-- just
directly access the variables instead.
.SS "\s-1MIDI EVENT ROUTINES\s0"
.IX Subsection "MIDI EVENT ROUTINES"
These routines, below, add a \s-1MIDI\s0 event to the Score, with a
start-time of Time.  Example:
.PP
.Vb 1
\&  text_event "And now the bongos!";  # procedure use
\&  
\&  $obj\->text_event "And now the bongos!";  # method use
.Ve
.PP
These are named after the \s-1MIDI\s0 events they add to the score, so see
MIDI::Event for an explanation of what the data types (like
\&\*(L"velocity\*(R" or \*(L"pitch_wheel\*(R") mean.  I've reordered this list so that
what I guess are the most important ones are toward the top:
.IP "patch_change \fIchannel\fR, \fIpatch\fR;" 4
.IX Item "patch_change channel, patch;"
.PD 0
.IP "key_after_touch \fIchannel\fR, \fInote\fR, \fIvelocity\fR;" 4
.IX Item "key_after_touch channel, note, velocity;"
.IP "channel_after_touch \fIchannel\fR, \fIvelocity\fR;" 4
.IX Item "channel_after_touch channel, velocity;"
.IP "control_change \fIchannel\fR, \fIcontroller(0\-127)\fR, \fIvalue(0\-127)\fR;" 4
.IX Item "control_change channel, controller(0-127), value(0-127);"
.IP "pitch_wheel_change \fIchannel\fR, \fIpitch_wheel\fR;" 4
.IX Item "pitch_wheel_change channel, pitch_wheel;"
.IP "set_tempo \fItempo\fR;  (See the section on tempo, below.)" 4
.IX Item "set_tempo tempo; (See the section on tempo, below.)"
.IP "smpte_offset \fIhr\fR, \fImn\fR, \fIse\fR, \fIfr\fR, \fIff\fR;" 4
.IX Item "smpte_offset hr, mn, se, fr, ff;"
.IP "time_signature \fInn\fR, \fIdd\fR, \fIcc\fR, \fIbb\fR;" 4
.IX Item "time_signature nn, dd, cc, bb;"
.IP "key_signature \fIsf\fR, \fImi\fR;" 4
.IX Item "key_signature sf, mi;"
.IP "text_event \fItext\fR;" 4
.IX Item "text_event text;"
.IP "copyright_text_event \fItext\fR;" 4
.IX Item "copyright_text_event text;"
.IP "track_name \fItext\fR;" 4
.IX Item "track_name text;"
.IP "instrument_name \fItext\fR;" 4
.IX Item "instrument_name text;"
.IP "lyric \fItext\fR;" 4
.IX Item "lyric text;"
.IP "set_sequence_number \fIsequence\fR;" 4
.IX Item "set_sequence_number sequence;"
.IP "marker \fItext\fR;" 4
.IX Item "marker text;"
.IP "cue_point \fItext\fR;" 4
.IX Item "cue_point text;"
.IP "sequencer_specific \fIraw\fR;" 4
.IX Item "sequencer_specific raw;"
.IP "sysex_f0 \fIraw\fR;" 4
.IX Item "sysex_f0 raw;"
.IP "sysex_f7 \fIraw\fR;" 4
.IX Item "sysex_f7 raw;"
.PD
.PP
And here's the ones I'll be surprised if anyone ever uses:
.IP "text_event_08 \fItext\fR;" 4
.IX Item "text_event_08 text;"
.PD 0
.IP "text_event_09 \fItext\fR;" 4
.IX Item "text_event_09 text;"
.IP "text_event_0a \fItext\fR;" 4
.IX Item "text_event_0a text;"
.IP "text_event_0b \fItext\fR;" 4
.IX Item "text_event_0b text;"
.IP "text_event_0c \fItext\fR;" 4
.IX Item "text_event_0c text;"
.IP "text_event_0d \fItext\fR;" 4
.IX Item "text_event_0d text;"
.IP "text_event_0e \fItext\fR;" 4
.IX Item "text_event_0e text;"
.IP "text_event_0f \fItext\fR;" 4
.IX Item "text_event_0f text;"
.IP "raw_meta_event \fIcommand\fR(0\-255), \fIraw\fR;" 4
.IX Item "raw_meta_event command(0-255), raw;"
.IP "song_position \fIstarttime\fR;" 4
.IX Item "song_position starttime;"
.IP "song_select \fIsong_number\fR;" 4
.IX Item "song_select song_number;"
.IP "tune_request \fIstarttime\fR;" 4
.IX Item "tune_request starttime;"
.IP "raw_data \fIraw\fR;" 4
.IX Item "raw_data raw;"
.IP "end_track \fIstarttime\fR;" 4
.IX Item "end_track starttime;"
.IP "note \fIduration\fR, \fIchannel\fR, \fInote\fR, \fIvelocity\fR;" 4
.IX Item "note duration, channel, note, velocity;"
.PD
.SS "About Tempo"
.IX Subsection "About Tempo"
The chart above shows that tempo is set with a method/procedure that
takes the form set_tempo(\fItempo\fR), and MIDI::Event says that
\&\fItempo\fR is \*(L"microseconds, a value 0 to 16,777,215 (0x00FFFFFF)\*(R".
But at the same time, you see that there's an attribute of the
MIDI::Simple object called \*(L"Tempo\*(R", which I've warned you to leave at
the default value of 96.  So you may wonder what the deal is.
.PP
The \*(L"Tempo\*(R" attribute (\s-1AKA\s0 \*(L"Divisions\*(R") is an integer that specifies
the number of \*(L"ticks\*(R" per \s-1MIDI\s0 quarter note.  Ticks is just the
notional timing unit all \s-1MIDI\s0 events are expressed in terms of.
Calling it \*(L"Tempo\*(R" is misleading, really; what you want to change to
make your music go faster or slower isn't that parameter, but instead
the mapping of ticks to actual time \*(-- and that is what \f(CW\*(C`set_tempo\*(C'\fR
does.  Its one parameter is the number of microseconds each quarter
note should get.
.PP
Suppose you wanted a tempo of 120 quarter notes per minute.  In terms
of microseconds per quarter note:
.PP
.Vb 1
\&  set_tempo 500_000; # you can use _ like a thousands\-separator comma
.Ve
.PP
In other words, this says to make each quarter note take up 500,000
microseconds, namely .5 seconds.  And there's 120 of those
half-seconds to the minute; so, 120 quarter notes to the minute.
.PP
If you see a \*(L"[quarter note symbol] = 160\*(R" in a piece of sheet music,
and you want to figure out what number you need for the \f(CW\*(C`set_tempo\*(C'\fR,
do:
.PP
.Vb 1
\&  60_000_000 / 160  ... and you get:  375_000
.Ve
.PP
Therefore, you should call:
.PP
.Vb 1
\&  set_tempo 375_000;
.Ve
.PP
So in other words, this general formula:
.PP
.Vb 1
\&  set_tempo int(60_000_000 / $quarter_notes_per_minute);
.Ve
.PP
should do you fine.
.PP
As to the Tempo/Duration parameter, leave it alone and just assume
that 96 ticks-per-quarter-note is a universal constant, and you'll be
happy.
.PP
(You may wonder: Why 96?  As far as I've worked out, all purmutations
of the normal note lengths (whole, half, quarter, eighth, sixteenth,
and even thirty-second notes) and tripletting, dotting, or
double-dotting, times 96, all produce integers.  For example, if a
quarter note is 96 ticks, then a double-dotted thirty-second note is
21 ticks (i.e., 1.75 * 1/8 * 96).  But that'd be a messy 10.5 if there
were only 48 ticks to a quarter note.  Now, if you wanted a quintuplet
anywhere, you'd be out of luck, since 96 isn't a factor of five.  It's
actually 3 * (2 ** 5), i.e., three times two to the fifth.  If you
really need quintuplets, then you have my very special permission to
mess with the Tempo attribute \*(-- I suggest multiples of 96, e.g., 5 *
96.)
.PP
(You may also have read in MIDI::Filespec that \f(CW\*(C`time_signature\*(C'\fR
allows you to define an arbitrary mapping of your concept of quarter
note, to \s-1MIDI\s0's concept of quarter note.  For your sanity and mine,
leave them the same, at a 1:1 mapping \*(-- i.e., with an '8' for
\&\f(CW\*(C`time_signature\*(C'\fR's last parameter, for \*(L"eight notated 32nd\-notes per
\&\s-1MIDI\s0 quarter note\*(R".  And this is relevant only if you're calling
\&\f(CW\*(C`time_signature\*(C'\fR anyway, which is not necessarily a given.)
.SS "\s-1MORE ROUTINES\s0"
.IX Subsection "MORE ROUTINES"
.ie n .IP "$opus = write_score \fIfilespec\fR" 4
.el .IP "\f(CW$opus\fR = write_score \fIfilespec\fR" 4
.IX Item "$opus = write_score filespec"
.PD 0
.ie n .IP "$opus = $obj\->write_score(\fIfilespec\fR)" 4
.el .IP "\f(CW$opus\fR = \f(CW$obj\fR\->write_score(\fIfilespec\fR)" 4
.IX Item "$opus = $obj->write_score(filespec)"
.PD
Writes the score to the filespec (e.g, \*(L"../../samples/funk2.midi\*(R", or
a variable containing that value), with the score's Ticks as its tick
parameters (\s-1AKA\s0 \*(L"divisions\*(R").  Among other things, this function calls
the function \f(CW\*(C`make_opus\*(C'\fR, below, and if you capture the output of
write_score, you'll get the opus created, if you want it for anything.
(Also: you can also use a filehandle-reference instead of the
filespec: \f(CW\*(C`write_score *STDOUT{IO}\*(C'\fR.)
.IP "read_score \fIfilespec\fR" 4
.IX Item "read_score filespec"
.PD 0
.ie n .IP "$obj = MIDI::Simple\->read_score('foo.mid'))" 4
.el .IP "\f(CW$obj\fR = MIDI::Simple\->read_score('foo.mid'))" 4
.IX Item "$obj = MIDI::Simple->read_score('foo.mid'))"
.PD
In the first case (a procedure call), does \f(CW\*(C`new_score\*(C'\fR to erase and
initialize the object attributes (Score, Octave, etc), then reads from
the file named.  The file named has to be a \s-1MIDI\s0 file with exactly one
eventful track, or Perl dies.  And in the second case, \f(CW\*(C`read_score\*(C'\fR
acts as a constructor method, returning a new object read from the
file.
.Sp
Score, Ticks, and Time are all affected:
.Sp
Score is the event form of all the \s-1MIDI\s0 events in the \s-1MIDI\s0 file.
(Note: \fISeriously\fR deformed \s-1MIDI\s0 files may confuse the routine that
turns \s-1MIDI\s0 events into a Score.)
.Sp
Ticks is set from the ticks setting (\s-1AKA\s0 \*(L"divisions\*(R") of the file.
.Sp
Time is set to the end time of the latest event in the file.
.Sp
(Also: you can also use a filehandle-reference instead of the
filespec: \f(CW\*(C`read_score *STDIN{IO}\*(C'\fR.)
.Sp
If ever you have to make a Score out of a single track from a
\&\fImultitrack\fR file, read the file into an \f(CW$opus\fR, and then consider
something like:
.Sp
.Vb 3
\&        new_score;
\&        $opus = MIDI::Opus\->new({ \*(Aqfrom_file\*(Aq => "foo2.mid" });
\&        $track = ($opus\->tracks)[2]; # get the third track
\&        
\&        ($score_r, $end_time) =
\&          MIDI::Score::events_r_to_score_r($track\->events_r);
\&
\&        $Ticks = $opus\->ticks;
\&        @Score =  @$score_r;
\&        $Time = $end_time;
.Ve
.IP "synch( \s-1LIST\s0 of coderefs )" 4
.IX Item "synch( LIST of coderefs )"
.PD 0
.ie n .IP "$obj\->synch( \s-1LIST\s0 of coderefs )" 4
.el .IP "\f(CW$obj\fR\->synch( \s-1LIST\s0 of coderefs )" 4
.IX Item "$obj->synch( LIST of coderefs )"
.PD
\&\s-1LIST\s0 is a list of coderefs (whether as a series of anonymous subs, or
as a list of items like \f(CW\*(C`(\e&foo, \e&bar, \e&baz)\*(C'\fR, or a mixture of
both) that \f(CW\*(C`synch\*(C'\fR calls in order to add to the given object \*(-- which
in the first form is the package's default object, and which in the
second case is \f(CW$obj\fR.  What \f(CW\*(C`synch\*(C'\fR does is:
.Sp
* remember the initial value of Time, before calling any of the
routines;
.Sp
* for each routine given, reset Time to what it was initially, call
the routine, and then note what the value of Time is, after each call;
.Sp
* then, after having called all of the routines, set Time to whatever
was the greatest (equals latest) value of Time that resulted from any
of the calls to the routines.
.Sp
The coderefs are all called with one argument in \f(CW@_\fR \*(-- the object
they are supposed to affect.  All these routines should/must therefore
use method calls instead of procedure calls.  Here's an example usage
of synch:
.Sp
.Vb 5
\&        my $measure = 0;
\&        my @phrases =(
\&          [ Cs, F,  Ds, Gs_d1 ], [Cs,    Ds, F, Cs],
\&          [ F,  Cs, Ds, Gs_d1 ], [Gs_d1, Ds, F, Cs]
\&        );
\&        
\&        for(1 .. 20) { synch(\e&count, \e&lalala); }
\&        
\&        sub count {
\&          my $it = $_[0];
\&          $it\->r(wn); # whole rest
\&          # not just "r(wn)" \-\- we want a method, not a procedure!
\&          ++$measure;
\&        }
\&        
\&        sub lalala {
\&          my $it = $_[0];
\&          $it\->noop(c1,mf,o3,qn); # setup
\&          my $phrase_number = ($measure + \-1) % 4;
\&          my @phrase = @{$phrases[$phrase_number]};
\&          foreach my $note (@phrase) { $it\->n($note); }
\&        }
.Ve
.ie n .IP "$opus = make_opus  or  $opus = $obj\->make_opus" 4
.el .IP "\f(CW$opus\fR = make_opus  or  \f(CW$opus\fR = \f(CW$obj\fR\->make_opus" 4
.IX Item "$opus = make_opus or $opus = $obj->make_opus"
Makes an opus (a MIDI::Opus object) out of Score, setting the opus's
tick parameter (\s-1AKA\s0 \*(L"divisions\*(R") to \f(CW$ticks\fR.  The opus is,
incidentally, format 0, with one track.
.ie n .IP "dump_score  or  $obj\->dump_score" 4
.el .IP "dump_score  or  \f(CW$obj\fR\->dump_score" 4
.IX Item "dump_score or $obj->dump_score"
Dumps Score's contents, via \f(CW\*(C`print\*(C'\fR (so you can \f(CW\*(C`select()\*(C'\fR an output
handle for it).  Currently this is in this somewhat uninspiring format:
.Sp
.Vb 2
\&  [\*(Aqnote\*(Aq, 0, 96, 1, 25, 96],
\&  [\*(Aqnote\*(Aq, 96, 96, 1, 29, 96],
.Ve
.Sp
as it is (currently) just a call to &MIDI::Score::dump_score; but in
the future I may (should?) make it output in \f(CW\*(C`n\*(C'\fR/\f(CW\*(C`r\*(C'\fR notation.  In
the meantime I assume you'll use this, if at all, only for debugging
purposes.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
These are subroutines that aren't methods and don't affect anything
(i.e., don't have \*(L"side effects\*(R") \*(-- they just take input and/or give
output.
.IP "interval \s-1LISTREF, LIST\s0" 4
.IX Item "interval LISTREF, LIST"
This takes a reference to a list of integers, and a list of note-pitch
specifications (whether relative or absolute), and returns a list
consisting of the given note specifications transposed by that many
half-steps.  E.g.,
.Sp
.Vb 1
\&  @majors = interval [0,4,7], C, Bflat3;
.Ve
.Sp
which returns the list \f(CW\*(C`(C,E,G,Bf3,D4,F4)\*(C'\fR.
.Sp
Items in \s-1LIST\s0 which aren't note specifications are passed thru
unaltered.
.IP "note_map { \s-1BLOCK\s0 } \s-1LIST\s0" 4
.IX Item "note_map { BLOCK } LIST"
This is pretty much based on (or at least inspired by) the normal Perl
\&\f(CW\*(C`map\*(C'\fR function, altho the syntax is a bit more restrictive (i.e.,
\&\f(CW\*(C`map\*(C'\fR can take the form \f(CW\*(C`map {BLOCK} LIST\*(C'\fR or \f(CW\*(C`map(EXPR,LIST)\*(C'\fR \*(--
the latter won't work with \f(CW\*(C`note_map\*(C'\fR).
.Sp
\&\f(CW\*(C`note_map {BLOCK} (LIST)\*(C'\fR evaluates the \s-1BLOCK\s0 for each element of
\&\s-1LIST\s0 (locally setting \f(CW$_\fR to each element's note-number value) and
returns the list value composed of the results of each such
evaluation.  Evaluates \s-1BLOCK\s0 in a list context, so each element of
\&\s-1LIST\s0 may produce zero, one, or more elements in the returned value.
Moreover, besides setting \f(CW$_\fR, \f(CW\*(C`note_map\*(C'\fR feeds \s-1BLOCK\s0 (which it sees
as an anonymous subroutine) three parameters, which \s-1BLOCK\s0 can access
in \f(CW@_\fR :
.Sp
.Vb 4
\&  $_[0]  :  Same as $_.  I.e., The current note\-specification,
\&            as a note number.
\&            This is the result of having fed the original note spec
\&            (which you can see in $_[2]) to is_note_spec.
\&
\&  $_[1]  :  The absoluteness flag for this note, from the
\&            above\-mentioned call to is_note_spec.
\&            0 = it was relative (like \*(AqC\*(Aq)
\&            1 = it was absolute (whether as \*(AqC4\*(Aq or \*(Aqn41\*(Aq or \*(Aq41\*(Aq)
\&
\&  $_[2] : the actual note specification from LIST, if you want
\&            to access it for any reason.
.Ve
.Sp
Incidentally, any items in \s-1LIST\s0 that aren't a note specification are
passed thru unchanged \*(-- \s-1BLOCK\s0 isn't called on it.
.Sp
So, in other words, what \f(CW\*(C`note_map\*(C'\fR does, for each item in \s-1LIST,\s0 is:
.Sp
* It calls \f(CW\*(C`is_note_spec\*(C'\fR on it to test whether it's a note
specification at all.  If it isn't, just passes it thru.  If it is,
then \f(CW\*(C`note_map\*(C'\fR stores the note number and the absoluteness flag that
\&\f(CW\*(C`is_note_spec\*(C'\fR returned, and...
.Sp
* It calls \s-1BLOCK,\s0 providing the note number in \f(CW$_\fR and \f(CW$_\fR[0], the
absoluteness flag in \f(CW$_\fR[1], and the original note specification in
\&\f(CW$_\fR[2].  Stores the return value of calling \s-1BLOCK\s0 (in a list context of
course) \*(-- this should be a list of note numbers.
.Sp
* For each element of the return value (which is actually free to be
an empty list), converts it from a note number to whatever \fBkind\fR of
specification the original note value was.  So, for each element, if
the original was relative, \f(CW\*(C`note_map\*(C'\fR interprets the return value as
a relative note number, and calls \f(CW\*(C`number_to_relative\*(C'\fR on it; if it
was absolute, \f(CW\*(C`note_map\*(C'\fR will try to restore it to the
correspondingly formatted absolute specification type.
.Sp
An example is, I hope, helpful:
.Sp
This:
.Sp
.Vb 1
\&        note_map { $_ \- 3, $_ + 2 }  qw(Cs3 n42 50 Bf)
.Ve
.Sp
returns this:
.Sp
.Vb 1
\&        (\*(AqBf2\*(Aq, \*(AqEf3\*(Aq, \*(Aqn39\*(Aq, \*(Aqn44\*(Aq, \*(Aq47\*(Aq, \*(Aq52\*(Aq, \*(AqG\*(Aq, \*(AqC_u1\*(Aq)
.Ve
.Sp
Or, to line things up:
.Sp
.Vb 4
\&          Cs3       n42       50      Bf
\&           |         |        |       |
\&        /\-\-\-\-\-\e   /\-\-\-\-\-\e   /\-\-\-\e   /\-\-\-\-\e
\&        Bf2 Ef3   n39 n44   47 52   G C_u1
.Ve
.Sp
Now, of course, this is the same as what this:
.Sp
.Vb 1
\&        interval [\-3, 2], qw(Cs3 n42 50 Bf)
.Ve
.Sp
returns.  This is fitting, as \f(CW\*(C`interval\*(C'\fR, internally, is basically a
simplified version of \f(CW\*(C`note_map\*(C'\fR.  But \f(CW\*(C`interval\*(C'\fR only lets you do
unconditional transposition, whereas \f(CW\*(C`note_map\*(C'\fR lets you do anything
at all.  For example:
.Sp
.Vb 2
\&       @note_specs = note_map { $funky_lookup_table{$_} }
\&                              C, Gf;
.Ve
.Sp
or
.Sp
.Vb 2
\&       @note_specs = note_map { $_ + int(rand(2)) }
\&                              @stuff;
.Ve
.Sp
\&\f(CW\*(C`note_map\*(C'\fR, like \f(CW\*(C`map\*(C'\fR, can seem confusing to beginning programmers
(and many intermediate ones, too), but it is quite powerful.
.IP "number_to_absolute \s-1NUMBER\s0" 4
.IX Item "number_to_absolute NUMBER"
This returns the absolute note specification (in the form \*(L"C5\*(R") that
the \s-1MIDI\s0 note number in \s-1NUMBER\s0 represents.
.Sp
This is like looking up the note number in \f(CW%MIDI::number2note\fR \*(-- not
exactly the same, but effectively the same.  See the source for more
details.
.IP "the function number_to_relative \s-1NUMBER\s0" 4
.IX Item "the function number_to_relative NUMBER"
This returns the relative note specification that \s-1NUMBER\s0 represents.
The idea of a numerical representation for \f(CW\*(C`relative\*(C'\fR note
specifications was necessitated by \f(CW\*(C`interval\*(C'\fR and \f(CW\*(C`note_map\*(C'\fR \*(--
since without this, you couldn't meaningfully say, for example,
interval [0,2] 'F'.  This should illustrate the concept:
.Sp
.Vb 7
\&          number_to_relative(\-10)   =>   "D_d1"
\&          number_to_relative( \-3)   =>   "A_d1"
\&          number_to_relative(  0)   =>   "C"
\&          number_to_relative(  5)   =>   "F"
\&          number_to_relative( 10)   =>   "Bf"
\&          number_to_relative( 19)   =>   "G_u1"
\&          number_to_relative( 40)   =>   "E_u3"
.Ve
.IP "is_note_spec \s-1STRING\s0" 4
.IX Item "is_note_spec STRING"
If \s-1STRING\s0 is a note specification, \f(CW\*(C`is_note_spec(STRING)\*(C'\fR returns a
list of two elements: first, a flag of whether the note specification
is absolute (flag value 1) or relative (flag value 0); and second, a
note number corresponding to that note specification.  If \s-1STRING\s0 is
not a note specification, \f(CW\*(C`is_note_spec(STRING)\*(C'\fR returns an empty
list (which in a boolean context is \s-1FALSE\s0).
.Sp
Implementationally, \f(CW\*(C`is_note_spec\*(C'\fR just uses \f(CW\*(C`is_absolute_note_spec\*(C'\fR
and \f(CW\*(C`is_relative_note_spec\*(C'\fR.
.Sp
Example usage:
.Sp
.Vb 7
\&        @note_details = is_note_spec($thing);
\&        if(@note_details) {
\&          ($absoluteness_flag, $note_num) = @note_details;
\&          ...stuff...
\&        } else {
\&          push @other_stuff, $thing;  # or whatever
\&        }
.Ve
.IP "is_relative_note_spec \s-1STRING\s0" 4
.IX Item "is_relative_note_spec STRING"
If \s-1STRING\s0 is an relative note specification, returns the note number
for that specification as a one-element list (which in a boolean
context is \s-1TRUE\s0).  Returns empty-list (which in a boolean context is
\&\s-1FALSE\s0) if \s-1STRING\s0 is \s-1NOT\s0 a relative note specification.
.Sp
To just get the boolean value:
.Sp
.Vb 1
\&      print "Snorf!\en" unless is_relative_note_spec($note);
.Ve
.Sp
But to actually get the note value:
.Sp
.Vb 1
\&      ($note_number) = is_relative_note_spec($note);
.Ve
.Sp
Or consider this:
.Sp
.Vb 6
\&      @is_rel = is_relative_note_spec($note);
\&      if(@is_rel) {
\&        $note_number = $is_rel[0];
\&      } else {
\&        print "Snorf!\en";
\&      }
.Ve
.Sp
(Author's note, two years later: all this business of returning lists
of various sizes, with this and other functions in here, is basically
a workaround for the fact that there's not really any such thing as a
boolean context in Perl \*(-- at least, not as far as user-defined
functions can see.  I now think I should have done this with just
returning a single scalar value: a number (which could be 0!) if the
input is a number, and undef/emptylist (\f(CW\*(C`return;\*(C'\fR) if not \*(-- then,
the user could test:
.Sp
.Vb 7
\&      # Hypothetical \-\-
\&      # This fuction doesn\*(Aqt actually work this way:
\&      if(defined(my $note_val = is_relative_note_spec($string))) {
\&         ...do things with $note_val...
\&      } else {
\&         print "Hey, that\*(Aqs no note!\en";
\&      }
.Ve
.Sp
However, I don't anticipate users actually using these messy functions
often at all \*(-- I basically wrote these for internal use by
MIDI::Simple, then I documented them on the off chance they \fImight\fR
be of use to anyone else.)
.IP "is_absolute_note_spec \s-1STRING\s0" 4
.IX Item "is_absolute_note_spec STRING"
Just like \f(CW\*(C`is_relative_note_spec\*(C'\fR, but for absolute note
specifications instead of relative ones.
.ie n .IP "\fBSelf()\fR or $obj\->\fBSelf()\fR;" 4
.el .IP "\fBSelf()\fR or \f(CW$obj\fR\->\fBSelf()\fR;" 4
.IX Item "Self() or $obj->Self();"
Presumably the second syntax is useless \*(-- it just returns \f(CW$obj\fR.  But
the first syntax returns the current package's default object.
.Sp
Suppose you write a routine, \f(CW\*(C`funkify\*(C'\fR, that does something-or-other
to a given MIDI::Simple object.  You could write it so that acts on
the current package's default object, which is fine \*(-- but, among
other things, that means you can't call \f(CW\*(C`funkify\*(C'\fR from a sub you have
\&\f(CW\*(C`synch\*(C'\fR call, since such routines should/must use only method calls.
So let's say that, instead, you write \f(CW\*(C`funkify\*(C'\fR so that the first
argument to it is the object to act on.  If the MIDI::Simple object
you want it to act on is it \f(CW$sonata\fR, you just say
.Sp
.Vb 1
\&  funkify($sonata)
.Ve
.Sp
However, if you want it to act on the current package's default
MIDI::Simple object, what to say?  Simply,
.Sp
.Vb 2
\&  $package_opus = Self;
\&  funkify($package_opus);
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2005 Sean M. Burke. All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
