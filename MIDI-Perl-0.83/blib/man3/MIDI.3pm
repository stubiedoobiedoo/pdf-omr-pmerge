.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MIDI 3pm"
.TH MIDI 3pm "2012-11-19" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIDI \- read, compose, modify, and write MIDI files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use MIDI;
\& use strict;
\& use warnings;
\& my @events = (
\&   [\*(Aqtext_event\*(Aq,0, \*(AqMORE COWBELL\*(Aq],
\&   [\*(Aqset_tempo\*(Aq, 0, 450_000], # 1qn = .45 seconds
\& );
\&
\& for (1 .. 20) {
\&   push @events,
\&     [\*(Aqnote_on\*(Aq , 90,  9, 56, 127],
\&     [\*(Aqnote_off\*(Aq,  6,  9, 56, 127],
\&   ;
\& }
\& foreach my $delay (reverse(1..96)) {
\&   push @events,
\&     [\*(Aqnote_on\*(Aq ,      0,  9, 56, 127],
\&     [\*(Aqnote_off\*(Aq, $delay,  9, 56, 127],
\&   ;
\& }
\&
\& my $cowbell_track = MIDI::Track\->new({ \*(Aqevents\*(Aq => \e@events });
\& my $opus = MIDI::Opus\->new(
\&  { \*(Aqformat\*(Aq => 0, \*(Aqticks\*(Aq => 96, \*(Aqtracks\*(Aq => [ $cowbell_track ] } );
\& $opus\->write_to_file( \*(Aqcowbell.mid\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This suite of modules provides routines for reading, composing, modifying,
and writing \s-1MIDI\s0 files.
.PP
From \s-1FOLDOC\s0 (\f(CW\*(C`http://wombat.doc.ic.ac.uk/foldoc/\*(C'\fR):
.Sp
.RS 4
\&\fB\s-1MIDI,\s0 Musical Instrument Digital Interface\fR
.Sp
<multimedia, file format> (\s-1MIDI\s0 /mi'\-dee/, /mee'\-dee/) A
hardware specification and protocol used to communicate note and
effect information between synthesisers, computers, music keyboards,
controllers and other electronic music devices. [...]
.Sp
The basic unit of information is a \*(L"note on/off\*(R" event which includes
a note number (pitch) and key velocity (loudness). There are many
other message types for events such as pitch bend, patch changes and
synthesizer-specific events for loading new patches etc.
.Sp
There is a file format for expressing \s-1MIDI\s0 data which is like a dump
of data sent over a \s-1MIDI\s0 port. [...]
.RE
.SH "COMPONENTS"
.IX Header "COMPONENTS"
The MIDI-Perl suite consists of these modules:
.PP
\&\s-1MIDI\s0 (which you're looking at), MIDI::Opus, MIDI::Track, 
MIDI::Event, MIDI::Score, and
MIDI::Simple.  All of these contain documentation in pod format.
You should read all of these pods.
.PP
The order you want to read them in will depend on what you want to do
with this suite of modules: if you are focused on manipulating the
guts of existing \s-1MIDI\s0 files, read the pods in the order given above.
.PP
But if you aim to compose music with this suite, read this pod, then
MIDI::Score and MIDI::Simple, and then skim the rest.
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This suite of modules is basically object-oriented, with the exception
of MIDI::Simple.  \s-1MIDI\s0 opuses (\*(L"songs\*(R") are represented as objects
belonging to the class MIDI::Opus.  An opus contains tracks, which are
objects belonging to the class MIDI::Track.  A track will generally
contain a list of events, where each event is a list consisting of a
command, a delta-time, and some number of parameters.  In other words,
opuses and tracks are objects, and the events in a track comprise a
LoL (and if you don't know what an LoL is, you must read perllol).
.PP
Furthermore, for some purposes it's useful to analyze the totality of
a track's events as a \*(L"score\*(R" \*(-- where a score consists of notes where
each event is a list consisting of a command, a time offset from the
start of the track, and some number of parameters.  This is the level
of abstraction that MIDI::Score and MIDI::Simple deal with.
.PP
While this suite does provide some functionality accessible only if
you're comfortable with various kinds of references, and while there
are some options that deal with the guts of \s-1MIDI\s0 encoding, you can (I
hope) get along just fine with just a basic grasp of the \s-1MIDI\s0
\&\*(L"standard\*(R", and a command of LoLs.  I have tried, at various points in
this documentation, to point out what things are not likely to be of
use to the casual user.
.SH "GOODIES"
.IX Header "GOODIES"
The bare module \s-1MIDI\s0.pm doesn't \fIdo\fR much more than \f(CW\*(C`use\*(C'\fR the
necessary component submodules (i.e., all except MIDI::Simple).  But
it does provide some hashes you might find useful:
.ie n .IP "%MIDI::note2number and %MIDI::number2note" 4
.el .IP "\f(CW%MIDI::note2number\fR and \f(CW%MIDI::number2note\fR" 4
.IX Item "%MIDI::note2number and %MIDI::number2note"
\&\f(CW%MIDI::number2note\fR correponds \s-1MIDI\s0 note numbers to a more
comprehensible representation (e.g., 68 to 'Gs4', for G\-sharp, octave
4); \f(CW%MIDI::note2number\fR is the reverse.  Have a look at the source
to see the contents of the hash.
.ie n .IP "%MIDI::patch2number and %MIDI::number2patch" 4
.el .IP "\f(CW%MIDI::patch2number\fR and \f(CW%MIDI::number2patch\fR" 4
.IX Item "%MIDI::patch2number and %MIDI::number2patch"
\&\f(CW%MIDI::number2patch\fR correponds General \s-1MIDI\s0 patch numbers
(0 to 127) to English names (e.g., 79 to 'Ocarina');
\&\f(CW%MIDI::patch2number\fR is the reverse.  Have a look at the source
to see the contents of the hash.
.ie n .IP "%MIDI::notenum2percussion and %MIDI::percussion2notenum" 4
.el .IP "\f(CW%MIDI::notenum2percussion\fR and \f(CW%MIDI::percussion2notenum\fR" 4
.IX Item "%MIDI::notenum2percussion and %MIDI::percussion2notenum"
\&\f(CW%MIDI::notenum2percussion\fR correponds General \s-1MIDI\s0 Percussion Keys
to English names (e.g., 56 to 'Cowbell') \*(-- but note that only numbers
35 to 81 (inclusive) are defined; \f(CW%MIDI::percussion2notenum\fR is the
reverse.  Have a look at the source to see the contents of the hash.
.SH "BRIEF GLOSSARY"
.IX Header "BRIEF GLOSSARY"
This glossary defines just a few terms, just enough so you can
(hopefully) make some sense of the documentation for this suite of
modules.  If you're going to do anything serious with these modules,
however, you \fIshould really\fR invest in a good book about the \s-1MIDI\s0
standard \*(-- see the References.
.PP
\&\fBchannel\fR: a logical channel to which control changes and patch
changes apply, and in which \s-1MIDI\s0 (note-related) events occur.
.PP
\&\fBcontrol\fR: one of the various numeric parameters associated with a
given channel.  Like S registers in Hayes-set modems, \s-1MIDI\s0 controls
consist of a few well-known registers, and beyond that, it's
patch-specific and/or sequencer-specific.
.PP
\&\fBdelta-time\fR: the time (in ticks) that a sequencer should wait
between playing the previous event and playing the current event.
.PP
\&\fBmeta-event\fR: any of a mixed bag of events whose common trait is
merely that they are similarly encoded.  Most meta-events apply to all
channels, unlike events, which mostly apply to just one channel.
.PP
\&\fBnote\fR: my oversimplistic term for items in a score structure.
.PP
\&\fBopus\fR: the term I prefer for a piece of music, as represented in
\&\s-1MIDI.\s0  Most specs use the term \*(L"song\*(R", but I think that this
falsely implies that \s-1MIDI\s0 files represent vocal pieces.
.PP
\&\fBpatch\fR: an electronic model of the sound of a given notional
instrument.
.PP
\&\fBrunning status\fR: a form of modest compression where an event lacking
an event command byte (a \*(L"status\*(R" byte) is to be interpreted as having
the same event command as the preceding event \*(-- which may, in turn,
lack a status byte and may have to be interpreted as having the same
event command as \fIits\fR previous event, and so on back.
.PP
\&\fBscore\fR: a structure of notes like an event structure, but where
notes are represented as single items, and where timing of items is
absolute from the beginning of the track, instead of being represented
in delta-times.
.PP
\&\fBsong\fR: what some \s-1MIDI\s0 specs call a song, I call an opus.
.PP
\&\fBsequencer\fR: a device or program that interprets and acts on \s-1MIDI\s0
data.  This prototypically refers to synthesizers or drum machines,
but can also refer to more limited devices, such as mixers or even
lighting control systems.
.PP
\&\fBstatus\fR: a synonym for \*(L"event\*(R".
.PP
\&\fBsysex\fR: a chunk of binary data encapsulated in the \s-1MIDI\s0 data stream,
for whatever purpose.
.PP
\&\fBtext event\fR: any of the several meta-events (one of which is
actually called 'text_event') that conveys text.  Most often used to
just label tracks, note the instruments used for a track, or to
provide metainformation about copyright, performer, and piece title
and author.
.PP
\&\fBtick\fR: the timing unit in a \s-1MIDI\s0 opus.
.PP
\&\fBvariable-length encoding\fR: an encoding method identical to what Perl
calls the 'w' (\s-1BER,\s0 Basic Encoding Rules) pack/unpack format for
integers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://interglacial.com/~sburke/midi\-perl/> \*(-- the MIDI-Perl homepage
on the Interwebs!
.PP
<http://search.cpan.org/search?m=module&q=MIDI&n=100> \*(-- All the \s-1MIDI\s0
things in \s-1CPAN\s0!
.SH "REFERENCES"
.IX Header "REFERENCES"
Christian Braut.  \fIThe Musician's Guide to Midi.\fR  \s-1ISBN 0782112854.\s0
[This one is indispensible, but sadly out of print.  Look at abebooks.com
for it maybe \-\-SMB]
.PP
Langston, Peter S.  1998. \*(L"Little Music Languages\*(R", p.587\-656 in:
Salus, Peter H,. editor in chief, /Handbook of Programming Languages/,
vol.  3.  MacMillan Technical, 1998.  [The volume it's in is probably
not worth the money, but see if you can at least glance at this
article anyway.  It's not often you see 70 pages written on music
languages. \-\-SMB]
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2005 Sean M. Burke. All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR (until 2010)
.PP
Darrell Conklin \f(CW\*(C`conklin@cpan.org\*(C'\fR (from 2010)
